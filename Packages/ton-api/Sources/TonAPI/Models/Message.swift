//
// Message.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct Message: Codable, JSONEncodable, Hashable {

    public enum MsgType: String, Codable, CaseIterable, CaseIterableDefaultsLast {
        case intMsg = "int_msg"
        case extInMsg = "ext_in_msg"
        case extOutMsg = "ext_out_msg"
        case unknownDefaultOpenApi = "unknown_default_open_api"
    }
    public var msgType: MsgType
    public var createdLt: Int64
    public var ihrDisabled: Bool
    public var bounce: Bool
    public var bounced: Bool
    public var value: Int64
    public var fwdFee: Int64
    public var ihrFee: Int64
    public var destination: AccountAddress?
    public var source: AccountAddress?
    public var importFee: Int64
    public var createdAt: Int64
    public var opCode: String?
    public var _init: StateInit?
    public var hash: String
    /** hex-encoded BoC with raw message body */
    public var rawBody: String?
    public var decodedOpName: String?
    public var decodedBody: AnyCodable?

    public init(msgType: MsgType, createdLt: Int64, ihrDisabled: Bool, bounce: Bool, bounced: Bool, value: Int64, fwdFee: Int64, ihrFee: Int64, destination: AccountAddress? = nil, source: AccountAddress? = nil, importFee: Int64, createdAt: Int64, opCode: String? = nil, _init: StateInit? = nil, hash: String, rawBody: String? = nil, decodedOpName: String? = nil, decodedBody: AnyCodable? = nil) {
        self.msgType = msgType
        self.createdLt = createdLt
        self.ihrDisabled = ihrDisabled
        self.bounce = bounce
        self.bounced = bounced
        self.value = value
        self.fwdFee = fwdFee
        self.ihrFee = ihrFee
        self.destination = destination
        self.source = source
        self.importFee = importFee
        self.createdAt = createdAt
        self.opCode = opCode
        self._init = _init
        self.hash = hash
        self.rawBody = rawBody
        self.decodedOpName = decodedOpName
        self.decodedBody = decodedBody
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case msgType = "msg_type"
        case createdLt = "created_lt"
        case ihrDisabled = "ihr_disabled"
        case bounce
        case bounced
        case value
        case fwdFee = "fwd_fee"
        case ihrFee = "ihr_fee"
        case destination
        case source
        case importFee = "import_fee"
        case createdAt = "created_at"
        case opCode = "op_code"
        case _init = "init"
        case hash
        case rawBody = "raw_body"
        case decodedOpName = "decoded_op_name"
        case decodedBody = "decoded_body"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(msgType, forKey: .msgType)
        try container.encode(createdLt, forKey: .createdLt)
        try container.encode(ihrDisabled, forKey: .ihrDisabled)
        try container.encode(bounce, forKey: .bounce)
        try container.encode(bounced, forKey: .bounced)
        try container.encode(value, forKey: .value)
        try container.encode(fwdFee, forKey: .fwdFee)
        try container.encode(ihrFee, forKey: .ihrFee)
        try container.encodeIfPresent(destination, forKey: .destination)
        try container.encodeIfPresent(source, forKey: .source)
        try container.encode(importFee, forKey: .importFee)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(opCode, forKey: .opCode)
        try container.encodeIfPresent(_init, forKey: ._init)
        try container.encode(hash, forKey: .hash)
        try container.encodeIfPresent(rawBody, forKey: .rawBody)
        try container.encodeIfPresent(decodedOpName, forKey: .decodedOpName)
        try container.encodeIfPresent(decodedBody, forKey: .decodedBody)
    }
}

