//
// BlockchainConfig29.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

/** The configuration for the consensus protocol above catchain. */
public struct BlockchainConfig29: Codable, JSONEncodable, Hashable {

    public var flags: Int?
    public var newCatchainIds: Bool?
    public var roundCandidates: Int64
    public var nextCandidateDelayMs: Int64
    public var consensusTimeoutMs: Int64
    public var fastAttempts: Int64
    public var attemptDuration: Int64
    public var catchainMaxDeps: Int64
    public var maxBlockBytes: Int64
    public var maxCollatedBytes: Int64
    public var protoVersion: Int64?
    public var catchainMaxBlocksCoeff: Int64?

    public init(flags: Int? = nil, newCatchainIds: Bool? = nil, roundCandidates: Int64, nextCandidateDelayMs: Int64, consensusTimeoutMs: Int64, fastAttempts: Int64, attemptDuration: Int64, catchainMaxDeps: Int64, maxBlockBytes: Int64, maxCollatedBytes: Int64, protoVersion: Int64? = nil, catchainMaxBlocksCoeff: Int64? = nil) {
        self.flags = flags
        self.newCatchainIds = newCatchainIds
        self.roundCandidates = roundCandidates
        self.nextCandidateDelayMs = nextCandidateDelayMs
        self.consensusTimeoutMs = consensusTimeoutMs
        self.fastAttempts = fastAttempts
        self.attemptDuration = attemptDuration
        self.catchainMaxDeps = catchainMaxDeps
        self.maxBlockBytes = maxBlockBytes
        self.maxCollatedBytes = maxCollatedBytes
        self.protoVersion = protoVersion
        self.catchainMaxBlocksCoeff = catchainMaxBlocksCoeff
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case flags
        case newCatchainIds = "new_catchain_ids"
        case roundCandidates = "round_candidates"
        case nextCandidateDelayMs = "next_candidate_delay_ms"
        case consensusTimeoutMs = "consensus_timeout_ms"
        case fastAttempts = "fast_attempts"
        case attemptDuration = "attempt_duration"
        case catchainMaxDeps = "catchain_max_deps"
        case maxBlockBytes = "max_block_bytes"
        case maxCollatedBytes = "max_collated_bytes"
        case protoVersion = "proto_version"
        case catchainMaxBlocksCoeff = "catchain_max_blocks_coeff"
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(flags, forKey: .flags)
        try container.encodeIfPresent(newCatchainIds, forKey: .newCatchainIds)
        try container.encode(roundCandidates, forKey: .roundCandidates)
        try container.encode(nextCandidateDelayMs, forKey: .nextCandidateDelayMs)
        try container.encode(consensusTimeoutMs, forKey: .consensusTimeoutMs)
        try container.encode(fastAttempts, forKey: .fastAttempts)
        try container.encode(attemptDuration, forKey: .attemptDuration)
        try container.encode(catchainMaxDeps, forKey: .catchainMaxDeps)
        try container.encode(maxBlockBytes, forKey: .maxBlockBytes)
        try container.encode(maxCollatedBytes, forKey: .maxCollatedBytes)
        try container.encodeIfPresent(protoVersion, forKey: .protoVersion)
        try container.encodeIfPresent(catchainMaxBlocksCoeff, forKey: .catchainMaxBlocksCoeff)
    }
}

