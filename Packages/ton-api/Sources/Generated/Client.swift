// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import struct Foundation.URL
@preconcurrency import struct Foundation.Data
@preconcurrency import struct Foundation.Date
#else
import struct Foundation.URL
import struct Foundation.Data
import struct Foundation.Date
#endif
import HTTPTypes
/// Provide access to indexed TON blockchain
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: Foundation.URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Get blockchain block data
    ///
    /// - Remark: HTTP `GET /v2/blockchain/blocks/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/blockchain/blocks/{block_id}/get(getBlockchainBlock)`.
    public func getBlockchainBlock(_ input: Operations.getBlockchainBlock.Input) async throws
        -> Operations.getBlockchainBlock.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainBlock.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/blocks/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainBlock.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainBlock.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get blockchain block shards
    ///
    /// - Remark: HTTP `GET /v2/blockchain/masterchain/{masterchain_seqno}/shards`.
    /// - Remark: Generated from `#/paths//v2/blockchain/masterchain/{masterchain_seqno}/shards/get(getBlockchainMasterchainShards)`.
    public func getBlockchainMasterchainShards(_ input: Operations.getBlockchainMasterchainShards.Input) async throws
        -> Operations.getBlockchainMasterchainShards.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainMasterchainShards.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/masterchain/{}/shards",
                    parameters: [input.path.masterchain_seqno]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainMasterchainShards.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainBlockShards.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all blocks in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain.  We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
    ///
    /// - Remark: HTTP `GET /v2/blockchain/masterchain/{masterchain_seqno}/blocks`.
    /// - Remark: Generated from `#/paths//v2/blockchain/masterchain/{masterchain_seqno}/blocks/get(getBlockchainMasterchainBlocks)`.
    public func getBlockchainMasterchainBlocks(_ input: Operations.getBlockchainMasterchainBlocks.Input) async throws
        -> Operations.getBlockchainMasterchainBlocks.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainMasterchainBlocks.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/masterchain/{}/blocks",
                    parameters: [input.path.masterchain_seqno]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainMasterchainBlocks.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainBlocks.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all transactions in all shards and workchains between target and previous masterchain block according to shards last blocks snapshot in masterchain. We don't recommend to build your app around this method because it has problem with scalability and will work very slow in the future.
    ///
    /// - Remark: HTTP `GET /v2/blockchain/masterchain/{masterchain_seqno}/transactions`.
    /// - Remark: Generated from `#/paths//v2/blockchain/masterchain/{masterchain_seqno}/transactions/get(getBlockchainMasterchainTransactions)`.
    public func getBlockchainMasterchainTransactions(_ input: Operations.getBlockchainMasterchainTransactions.Input)
        async throws -> Operations.getBlockchainMasterchainTransactions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainMasterchainTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/masterchain/{}/transactions",
                    parameters: [input.path.masterchain_seqno]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainMasterchainTransactions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transactions.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get blockchain config from a specific block, if present.
    ///
    /// - Remark: HTTP `GET /v2/blockchain/masterchain/{masterchain_seqno}/config`.
    /// - Remark: Generated from `#/paths//v2/blockchain/masterchain/{masterchain_seqno}/config/get(getBlockchainConfigFromBlock)`.
    public func getBlockchainConfigFromBlock(_ input: Operations.getBlockchainConfigFromBlock.Input) async throws
        -> Operations.getBlockchainConfigFromBlock.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainConfigFromBlock.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/masterchain/{}/config",
                    parameters: [input.path.masterchain_seqno]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainConfigFromBlock.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainConfig.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw blockchain config from a specific block, if present.
    ///
    /// - Remark: HTTP `GET /v2/blockchain/masterchain/{masterchain_seqno}/config/raw`.
    /// - Remark: Generated from `#/paths//v2/blockchain/masterchain/{masterchain_seqno}/config/raw/get(getRawBlockchainConfigFromBlock)`.
    public func getRawBlockchainConfigFromBlock(_ input: Operations.getRawBlockchainConfigFromBlock.Input) async throws
        -> Operations.getRawBlockchainConfigFromBlock.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawBlockchainConfigFromBlock.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/masterchain/{}/config/raw",
                    parameters: [input.path.masterchain_seqno]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawBlockchainConfigFromBlock.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RawBlockchainConfig.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get transactions from block
    ///
    /// - Remark: HTTP `GET /v2/blockchain/blocks/{block_id}/transactions`.
    /// - Remark: Generated from `#/paths//v2/blockchain/blocks/{block_id}/transactions/get(getBlockchainBlockTransactions)`.
    public func getBlockchainBlockTransactions(_ input: Operations.getBlockchainBlockTransactions.Input) async throws
        -> Operations.getBlockchainBlockTransactions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainBlockTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/blocks/{}/transactions",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainBlockTransactions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transactions.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get transaction data
    ///
    /// - Remark: HTTP `GET /v2/blockchain/transactions/{transaction_id}`.
    /// - Remark: Generated from `#/paths//v2/blockchain/transactions/{transaction_id}/get(getBlockchainTransaction)`.
    public func getBlockchainTransaction(_ input: Operations.getBlockchainTransaction.Input) async throws
        -> Operations.getBlockchainTransaction.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainTransaction.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/transactions/{}",
                    parameters: [input.path.transaction_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainTransaction.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transaction.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get transaction data by message hash
    ///
    /// - Remark: HTTP `GET /v2/blockchain/messages/{msg_id}/transaction`.
    /// - Remark: Generated from `#/paths//v2/blockchain/messages/{msg_id}/transaction/get(getBlockchainTransactionByMessageHash)`.
    public func getBlockchainTransactionByMessageHash(_ input: Operations.getBlockchainTransactionByMessageHash.Input)
        async throws -> Operations.getBlockchainTransactionByMessageHash.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainTransactionByMessageHash.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/messages/{}/transaction",
                    parameters: [input.path.msg_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainTransactionByMessageHash.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transaction.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get blockchain validators
    ///
    /// - Remark: HTTP `GET /v2/blockchain/validators`.
    /// - Remark: Generated from `#/paths//v2/blockchain/validators/get(getBlockchainValidators)`.
    public func getBlockchainValidators(_ input: Operations.getBlockchainValidators.Input) async throws
        -> Operations.getBlockchainValidators.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainValidators.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/blockchain/validators", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainValidators.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Validators.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get last known masterchain block
    ///
    /// - Remark: HTTP `GET /v2/blockchain/masterchain-head`.
    /// - Remark: Generated from `#/paths//v2/blockchain/masterchain-head/get(getBlockchainMasterchainHead)`.
    public func getBlockchainMasterchainHead(_ input: Operations.getBlockchainMasterchainHead.Input) async throws
        -> Operations.getBlockchainMasterchainHead.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainMasterchainHead.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/blockchain/masterchain-head", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainMasterchainHead.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainBlock.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get low-level information about an account taken directly from the blockchain.
    ///
    /// - Remark: HTTP `GET /v2/blockchain/accounts/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/blockchain/accounts/{account_id}/get(getBlockchainRawAccount)`.
    public func getBlockchainRawAccount(_ input: Operations.getBlockchainRawAccount.Input) async throws
        -> Operations.getBlockchainRawAccount.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainRawAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/accounts/{}",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainRawAccount.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainRawAccount.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get account transactions
    ///
    /// - Remark: HTTP `GET /v2/blockchain/accounts/{account_id}/transactions`.
    /// - Remark: Generated from `#/paths//v2/blockchain/accounts/{account_id}/transactions/get(getBlockchainAccountTransactions)`.
    public func getBlockchainAccountTransactions(_ input: Operations.getBlockchainAccountTransactions.Input)
        async throws -> Operations.getBlockchainAccountTransactions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainAccountTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/accounts/{}/transactions",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "after_lt",
                    value: input.query.after_lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before_lt",
                    value: input.query.before_lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainAccountTransactions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Transactions.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Execute get method for account
    ///
    /// - Remark: HTTP `GET /v2/blockchain/accounts/{account_id}/methods/{method_name}`.
    /// - Remark: Generated from `#/paths//v2/blockchain/accounts/{account_id}/methods/{method_name}/get(execGetMethodForBlockchainAccount)`.
    public func execGetMethodForBlockchainAccount(_ input: Operations.execGetMethodForBlockchainAccount.Input)
        async throws -> Operations.execGetMethodForBlockchainAccount.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.execGetMethodForBlockchainAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/accounts/{}/methods/{}",
                    parameters: [input.path.account_id, input.path.method_name]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "args",
                    value: input.query.args
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.execGetMethodForBlockchainAccount.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MethodExecutionResult.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Send message to blockchain
    ///
    /// - Remark: HTTP `POST /v2/blockchain/message`.
    /// - Remark: Generated from `#/paths//v2/blockchain/message/post(sendBlockchainMessage)`.
    public func sendBlockchainMessage(_ input: Operations.sendBlockchainMessage.Input) async throws
        -> Operations.sendBlockchainMessage.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.sendBlockchainMessage.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/blockchain/message", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200: return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get blockchain config
    ///
    /// - Remark: HTTP `GET /v2/blockchain/config`.
    /// - Remark: Generated from `#/paths//v2/blockchain/config/get(getBlockchainConfig)`.
    public func getBlockchainConfig(_ input: Operations.getBlockchainConfig.Input) async throws
        -> Operations.getBlockchainConfig.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getBlockchainConfig.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/blockchain/config", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getBlockchainConfig.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainConfig.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw blockchain config
    ///
    /// - Remark: HTTP `GET /v2/blockchain/config/raw`.
    /// - Remark: Generated from `#/paths//v2/blockchain/config/raw/get(getRawBlockchainConfig)`.
    public func getRawBlockchainConfig(_ input: Operations.getRawBlockchainConfig.Input) async throws
        -> Operations.getRawBlockchainConfig.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawBlockchainConfig.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/blockchain/config/raw", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawBlockchainConfig.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.RawBlockchainConfig.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Blockchain account inspect
    ///
    /// - Remark: HTTP `GET /v2/blockchain/accounts/{account_id}/inspect`.
    /// - Remark: Generated from `#/paths//v2/blockchain/accounts/{account_id}/inspect/get(blockchainAccountInspect)`.
    public func blockchainAccountInspect(_ input: Operations.blockchainAccountInspect.Input) async throws
        -> Operations.blockchainAccountInspect.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.blockchainAccountInspect.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/blockchain/accounts/{}/inspect",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.blockchainAccountInspect.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.BlockchainAccountInspect.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Decode a given message. Only external incoming messages can be decoded currently.
    ///
    /// - Remark: HTTP `POST /v2/message/decode`.
    /// - Remark: Generated from `#/paths//v2/message/decode/post(decodeMessage)`.
    public func decodeMessage(_ input: Operations.decodeMessage.Input) async throws -> Operations.decodeMessage.Output {
        try await client.send(
            input: input,
            forOperation: Operations.decodeMessage.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/message/decode", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.decodeMessage.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DecodedMessage.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// parse address and display in all formats
    ///
    /// - Remark: HTTP `GET /v2/address/{account_id}/parse`.
    /// - Remark: Generated from `#/paths//v2/address/{account_id}/parse/get(addressParse)`.
    public func addressParse(_ input: Operations.addressParse.Input) async throws -> Operations.addressParse.Output {
        try await client.send(
            input: input,
            forOperation: Operations.addressParse.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/address/{}/parse",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.addressParse.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.addressParse.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Emulate sending message to blockchain
    ///
    /// - Remark: HTTP `POST /v2/events/emulate`.
    /// - Remark: Generated from `#/paths//v2/events/emulate/post(emulateMessageToEvent)`.
    public func emulateMessageToEvent(_ input: Operations.emulateMessageToEvent.Input) async throws
        -> Operations.emulateMessageToEvent.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.emulateMessageToEvent.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/events/emulate", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ignore_signature_check",
                    value: input.query.ignore_signature_check
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.emulateMessageToEvent.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Event.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Emulate sending message to blockchain
    ///
    /// - Remark: HTTP `POST /v2/traces/emulate`.
    /// - Remark: Generated from `#/paths//v2/traces/emulate/post(emulateMessageToTrace)`.
    public func emulateMessageToTrace(_ input: Operations.emulateMessageToTrace.Input) async throws
        -> Operations.emulateMessageToTrace.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.emulateMessageToTrace.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/traces/emulate", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ignore_signature_check",
                    value: input.query.ignore_signature_check
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.emulateMessageToTrace.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Trace.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Emulate sending message to blockchain
    ///
    /// - Remark: HTTP `POST /v2/wallet/emulate`.
    /// - Remark: Generated from `#/paths//v2/wallet/emulate/post(emulateMessageToWallet)`.
    public func emulateMessageToWallet(_ input: Operations.emulateMessageToWallet.Input) async throws
        -> Operations.emulateMessageToWallet.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.emulateMessageToWallet.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/wallet/emulate", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.emulateMessageToWallet.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.MessageConsequences.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Emulate sending message to blockchain
    ///
    /// - Remark: HTTP `POST /v2/accounts/{account_id}/events/emulate`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/events/emulate/post(emulateMessageToAccountEvent)`.
    public func emulateMessageToAccountEvent(_ input: Operations.emulateMessageToAccountEvent.Input) async throws
        -> Operations.emulateMessageToAccountEvent.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.emulateMessageToAccountEvent.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/events/emulate",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.emulateMessageToAccountEvent.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountEvent.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get human-friendly information about several accounts without low-level details.
    ///
    /// - Remark: HTTP `POST /v2/accounts/_bulk`.
    /// - Remark: Generated from `#/paths//v2/accounts/_bulk/post(getAccounts)`.
    public func getAccounts(_ input: Operations.getAccounts.Input) async throws -> Operations.getAccounts.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/accounts/_bulk", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none: body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccounts.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Accounts.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get human-friendly information about an account without low-level details.
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/get(getAccount)`.
    public func getAccount(_ input: Operations.getAccount.Input) async throws -> Operations.getAccount.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/accounts/{}", parameters: [input.path.account_id])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccount.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Account.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get account's domains
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/dns/backresolve`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/dns/backresolve/get(accountDnsBackResolve)`.
    public func accountDnsBackResolve(_ input: Operations.accountDnsBackResolve.Input) async throws
        -> Operations.accountDnsBackResolve.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.accountDnsBackResolve.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/dns/backresolve",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.accountDnsBackResolve.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DomainNames.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all Jettons balances by owner address
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/jettons`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/jettons/get(getAccountJettonsBalances)`.
    public func getAccountJettonsBalances(_ input: Operations.getAccountJettonsBalances.Input) async throws
        -> Operations.getAccountJettonsBalances.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountJettonsBalances.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/jettons",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "currencies",
                    value: input.query.currencies
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountJettonsBalances.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.JettonsBalances.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get the transfer jettons history for account
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/jettons/history`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/jettons/history/get(getAccountJettonsHistory)`.
    public func getAccountJettonsHistory(_ input: Operations.getAccountJettonsHistory.Input) async throws
        -> Operations.getAccountJettonsHistory.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountJettonsHistory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/jettons/history",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before_lt",
                    value: input.query.before_lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountJettonsHistory.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountEvents.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get the transfer jetton history for account and jetton
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/jettons/{jetton_id}/history`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/jettons/{jetton_id}/history/get(getAccountJettonHistoryByID)`.
    public func getAccountJettonHistoryByID(_ input: Operations.getAccountJettonHistoryByID.Input) async throws
        -> Operations.getAccountJettonHistoryByID.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountJettonHistoryByID.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/jettons/{}/history",
                    parameters: [input.path.account_id, input.path.jetton_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before_lt",
                    value: input.query.before_lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountJettonHistoryByID.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountEvents.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all NFT items by owner address
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/nfts`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/nfts/get(getAccountNftItems)`.
    public func getAccountNftItems(_ input: Operations.getAccountNftItems.Input) async throws
        -> Operations.getAccountNftItems.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountNftItems.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/nfts",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "collection",
                    value: input.query.collection
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "indirect_ownership",
                    value: input.query.indirect_ownership
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountNftItems.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NftItems.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get the transfer nft history
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/nfts/history`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/nfts/history/get(getAccountNftHistory)`.
    public func getAccountNftHistory(_ input: Operations.getAccountNftHistory.Input) async throws
        -> Operations.getAccountNftHistory.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountNftHistory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/nfts/history",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before_lt",
                    value: input.query.before_lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountNftHistory.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountEvents.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get events for an account. Each event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/events`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/events/get(getAccountEvents)`.
    public func getAccountEvents(_ input: Operations.getAccountEvents.Input) async throws
        -> Operations.getAccountEvents.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountEvents.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/events",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "initiator",
                    value: input.query.initiator
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "subject_only",
                    value: input.query.subject_only
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before_lt",
                    value: input.query.before_lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountEvents.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountEvents.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get event for an account by event_id
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/events/{event_id}`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/events/{event_id}/get(getAccountEvent)`.
    public func getAccountEvent(_ input: Operations.getAccountEvent.Input) async throws
        -> Operations.getAccountEvent.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountEvent.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/events/{}",
                    parameters: [input.path.account_id, input.path.event_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "subject_only",
                    value: input.query.subject_only
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountEvent.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountEvent.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get traces for account
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/traces`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/traces/get(getAccountTraces)`.
    public func getAccountTraces(_ input: Operations.getAccountTraces.Input) async throws
        -> Operations.getAccountTraces.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountTraces.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/traces",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountTraces.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.TraceIDs.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all subscriptions by wallet address
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/subscriptions`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/subscriptions/get(getAccountSubscriptions)`.
    public func getAccountSubscriptions(_ input: Operations.getAccountSubscriptions.Input) async throws
        -> Operations.getAccountSubscriptions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountSubscriptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/subscriptions",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountSubscriptions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Subscriptions.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Update internal cache for a particular account
    ///
    /// - Remark: HTTP `POST /v2/accounts/{account_id}/reindex`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/reindex/post(reindexAccount)`.
    public func reindexAccount(_ input: Operations.reindexAccount.Input) async throws
        -> Operations.reindexAccount.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.reindexAccount.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/reindex",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200: return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Search by account domain name
    ///
    /// - Remark: HTTP `GET /v2/accounts/search`.
    /// - Remark: Generated from `#/paths//v2/accounts/search/get(searchAccounts)`.
    public func searchAccounts(_ input: Operations.searchAccounts.Input) async throws
        -> Operations.searchAccounts.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.searchAccounts.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/accounts/search", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.searchAccounts.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.FoundAccounts.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get expiring account .ton dns
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/dns/expiring`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/dns/expiring/get(getAccountDnsExpiring)`.
    public func getAccountDnsExpiring(_ input: Operations.getAccountDnsExpiring.Input) async throws
        -> Operations.getAccountDnsExpiring.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountDnsExpiring.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/dns/expiring",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "period",
                    value: input.query.period
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountDnsExpiring.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DnsExpiring.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get public key by account id
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/publickey`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/publickey/get(getAccountPublicKey)`.
    public func getAccountPublicKey(_ input: Operations.getAccountPublicKey.Input) async throws
        -> Operations.getAccountPublicKey.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountPublicKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/publickey",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountPublicKey.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getAccountPublicKey.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get account's balance change
    ///
    /// - Remark: HTTP `GET /v2/accounts/{account_id}/diff`.
    /// - Remark: Generated from `#/paths//v2/accounts/{account_id}/diff/get(getAccountDiff)`.
    public func getAccountDiff(_ input: Operations.getAccountDiff.Input) async throws
        -> Operations.getAccountDiff.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountDiff.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/accounts/{}/diff",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountDiff.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getAccountDiff.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get full information about domain name
    ///
    /// - Remark: HTTP `GET /v2/dns/{domain_name}`.
    /// - Remark: Generated from `#/paths//v2/dns/{domain_name}/get(getDnsInfo)`.
    public func getDnsInfo(_ input: Operations.getDnsInfo.Input) async throws -> Operations.getDnsInfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDnsInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/dns/{}", parameters: [input.path.domain_name])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDnsInfo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DomainInfo.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// DNS resolve for domain name
    ///
    /// - Remark: HTTP `GET /v2/dns/{domain_name}/resolve`.
    /// - Remark: Generated from `#/paths//v2/dns/{domain_name}/resolve/get(dnsResolve)`.
    public func dnsResolve(_ input: Operations.dnsResolve.Input) async throws -> Operations.dnsResolve.Output {
        try await client.send(
            input: input,
            forOperation: Operations.dnsResolve.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/dns/{}/resolve",
                    parameters: [input.path.domain_name]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.dnsResolve.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DnsRecord.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get domain bids
    ///
    /// - Remark: HTTP `GET /v2/dns/{domain_name}/bids`.
    /// - Remark: Generated from `#/paths//v2/dns/{domain_name}/bids/get(getDomainBids)`.
    public func getDomainBids(_ input: Operations.getDomainBids.Input) async throws -> Operations.getDomainBids.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getDomainBids.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/dns/{}/bids", parameters: [input.path.domain_name])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getDomainBids.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.DomainBids.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all auctions
    ///
    /// - Remark: HTTP `GET /v2/dns/auctions`.
    /// - Remark: Generated from `#/paths//v2/dns/auctions/get(getAllAuctions)`.
    public func getAllAuctions(_ input: Operations.getAllAuctions.Input) async throws
        -> Operations.getAllAuctions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAllAuctions.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/dns/auctions", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tld",
                    value: input.query.tld
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllAuctions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Auctions.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get NFT collections
    ///
    /// - Remark: HTTP `GET /v2/nfts/collections`.
    /// - Remark: Generated from `#/paths//v2/nfts/collections/get(getNftCollections)`.
    public func getNftCollections(_ input: Operations.getNftCollections.Input) async throws
        -> Operations.getNftCollections.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getNftCollections.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/nfts/collections", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNftCollections.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NftCollections.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get NFT collection by collection address
    ///
    /// - Remark: HTTP `GET /v2/nfts/collections/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/nfts/collections/{account_id}/get(getNftCollection)`.
    public func getNftCollection(_ input: Operations.getNftCollection.Input) async throws
        -> Operations.getNftCollection.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getNftCollection.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/nfts/collections/{}",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNftCollection.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NftCollection.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get NFT items from collection by collection address
    ///
    /// - Remark: HTTP `GET /v2/nfts/collections/{account_id}/items`.
    /// - Remark: Generated from `#/paths//v2/nfts/collections/{account_id}/items/get(getItemsFromCollection)`.
    public func getItemsFromCollection(_ input: Operations.getItemsFromCollection.Input) async throws
        -> Operations.getItemsFromCollection.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getItemsFromCollection.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/nfts/collections/{}/items",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getItemsFromCollection.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NftItems.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get NFT items by their addresses
    ///
    /// - Remark: HTTP `POST /v2/nfts/_bulk`.
    /// - Remark: Generated from `#/paths//v2/nfts/_bulk/post(getNftItemsByAddresses)`.
    public func getNftItemsByAddresses(_ input: Operations.getNftItemsByAddresses.Input) async throws
        -> Operations.getNftItemsByAddresses.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getNftItemsByAddresses.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/nfts/_bulk", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case .none: body = nil
                case let .json(value):
                    body = try converter.setOptionalRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNftItemsByAddresses.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NftItems.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get NFT item by its address
    ///
    /// - Remark: HTTP `GET /v2/nfts/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/nfts/{account_id}/get(getNftItemByAddress)`.
    public func getNftItemByAddress(_ input: Operations.getNftItemByAddress.Input) async throws
        -> Operations.getNftItemByAddress.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getNftItemByAddress.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/nfts/{}", parameters: [input.path.account_id])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNftItemByAddress.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.NftItem.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get the transfer nfts history for account
    ///
    /// - Remark: HTTP `GET /v2/nfts/{account_id}/history`.
    /// - Remark: Generated from `#/paths//v2/nfts/{account_id}/history/get(getNftHistoryByID)`.
    public func getNftHistoryByID(_ input: Operations.getNftHistoryByID.Input) async throws
        -> Operations.getNftHistoryByID.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getNftHistoryByID.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/nfts/{}/history",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "before_lt",
                    value: input.query.before_lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getNftHistoryByID.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountEvents.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get the trace by trace ID or hash of any transaction in trace
    ///
    /// - Remark: HTTP `GET /v2/traces/{trace_id}`.
    /// - Remark: Generated from `#/paths//v2/traces/{trace_id}/get(getTrace)`.
    public func getTrace(_ input: Operations.getTrace.Input) async throws -> Operations.getTrace.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getTrace.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/traces/{}", parameters: [input.path.trace_id])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTrace.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Trace.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get an event either by event ID or a hash of any transaction in a trace. An event is built on top of a trace which is a series of transactions caused by one inbound message. TonAPI looks for known patterns inside the trace and splits the trace into actions, where a single action represents a meaningful high-level operation like a Jetton Transfer or an NFT Purchase. Actions are expected to be shown to users. It is advised not to build any logic on top of actions because actions can be changed at any time.
    ///
    /// - Remark: HTTP `GET /v2/events/{event_id}`.
    /// - Remark: Generated from `#/paths//v2/events/{event_id}/get(getEvent)`.
    public func getEvent(_ input: Operations.getEvent.Input) async throws -> Operations.getEvent.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getEvent.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/events/{}", parameters: [input.path.event_id])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getEvent.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Event.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all inscriptions by owner address. It's experimental API and can be dropped in the future.
    ///
    /// - Remark: HTTP `GET /v2/experimental/accounts/{account_id}/inscriptions`.
    /// - Remark: Generated from `#/paths//v2/experimental/accounts/{account_id}/inscriptions/get(getAccountInscriptions)`.
    public func getAccountInscriptions(_ input: Operations.getAccountInscriptions.Input) async throws
        -> Operations.getAccountInscriptions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountInscriptions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/experimental/accounts/{}/inscriptions",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountInscriptions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.InscriptionBalances.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// return comment for making operation with instrospection. please don't use it if you don't know what you are doing
    ///
    /// - Remark: HTTP `GET /v2/experimental/inscriptions/op-template`.
    /// - Remark: Generated from `#/paths//v2/experimental/inscriptions/op-template/get(getInscriptionOpTemplate)`.
    public func getInscriptionOpTemplate(_ input: Operations.getInscriptionOpTemplate.Input) async throws
        -> Operations.getInscriptionOpTemplate.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getInscriptionOpTemplate.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/experimental/inscriptions/op-template",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "type",
                    value: input.query._type
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "destination",
                    value: input.query.destination
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "comment",
                    value: input.query.comment
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "operation",
                    value: input.query.operation
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "amount",
                    value: input.query.amount
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "ticker",
                    value: input.query.ticker
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "who",
                    value: input.query.who
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getInscriptionOpTemplate.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getInscriptionOpTemplate.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get a list of all indexed jetton masters in the blockchain.
    ///
    /// - Remark: HTTP `GET /v2/jettons`.
    /// - Remark: Generated from `#/paths//v2/jettons/get(getJettons)`.
    public func getJettons(_ input: Operations.getJettons.Input) async throws -> Operations.getJettons.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getJettons.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/jettons", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getJettons.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Jettons.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get jetton metadata by jetton master address
    ///
    /// - Remark: HTTP `GET /v2/jettons/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/jettons/{account_id}/get(getJettonInfo)`.
    public func getJettonInfo(_ input: Operations.getJettonInfo.Input) async throws -> Operations.getJettonInfo.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getJettonInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/jettons/{}", parameters: [input.path.account_id])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getJettonInfo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.JettonInfo.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get jetton's holders
    ///
    /// - Remark: HTTP `GET /v2/jettons/{account_id}/holders`.
    /// - Remark: Generated from `#/paths//v2/jettons/{account_id}/holders/get(getJettonHolders)`.
    public func getJettonHolders(_ input: Operations.getJettonHolders.Input) async throws
        -> Operations.getJettonHolders.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getJettonHolders.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/jettons/{}/holders",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "limit",
                    value: input.query.limit
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "offset",
                    value: input.query.offset
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getJettonHolders.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.JettonHolders.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get only jetton transfers in the event
    ///
    /// - Remark: HTTP `GET /v2/events/{event_id}/jettons`.
    /// - Remark: Generated from `#/paths//v2/events/{event_id}/jettons/get(getJettonsEvents)`.
    public func getJettonsEvents(_ input: Operations.getJettonsEvents.Input) async throws
        -> Operations.getJettonsEvents.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getJettonsEvents.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/events/{}/jettons",
                    parameters: [input.path.event_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getJettonsEvents.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Event.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// All pools where account participates
    ///
    /// - Remark: HTTP `GET /v2/staking/nominator/{account_id}/pools`.
    /// - Remark: Generated from `#/paths//v2/staking/nominator/{account_id}/pools/get(getAccountNominatorsPools)`.
    public func getAccountNominatorsPools(_ input: Operations.getAccountNominatorsPools.Input) async throws
        -> Operations.getAccountNominatorsPools.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountNominatorsPools.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/staking/nominator/{}/pools",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountNominatorsPools.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountStaking.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Stacking pool info
    ///
    /// - Remark: HTTP `GET /v2/staking/pool/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/staking/pool/{account_id}/get(getStakingPoolInfo)`.
    public func getStakingPoolInfo(_ input: Operations.getStakingPoolInfo.Input) async throws
        -> Operations.getStakingPoolInfo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getStakingPoolInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/staking/pool/{}",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStakingPoolInfo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getStakingPoolInfo.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Pool history
    ///
    /// - Remark: HTTP `GET /v2/staking/pool/{account_id}/history`.
    /// - Remark: Generated from `#/paths//v2/staking/pool/{account_id}/history/get(getStakingPoolHistory)`.
    public func getStakingPoolHistory(_ input: Operations.getStakingPoolHistory.Input) async throws
        -> Operations.getStakingPoolHistory.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getStakingPoolHistory.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/staking/pool/{}/history",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStakingPoolHistory.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getStakingPoolHistory.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// All pools available in network
    ///
    /// - Remark: HTTP `GET /v2/staking/pools`.
    /// - Remark: Generated from `#/paths//v2/staking/pools/get(getStakingPools)`.
    public func getStakingPools(_ input: Operations.getStakingPools.Input) async throws
        -> Operations.getStakingPools.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getStakingPools.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/staking/pools", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "available_for",
                    value: input.query.available_for
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "include_unverified",
                    value: input.query.include_unverified
                )
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "Accept-Language",
                    value: input.headers.Accept_hyphen_Language
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStakingPools.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getStakingPools.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get TON storage providers deployed to the blockchain.
    ///
    /// - Remark: HTTP `GET /v2/storage/providers`.
    /// - Remark: Generated from `#/paths//v2/storage/providers/get(getStorageProviders)`.
    public func getStorageProviders(_ input: Operations.getStorageProviders.Input) async throws
        -> Operations.getStorageProviders.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getStorageProviders.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/storage/providers", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getStorageProviders.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getStorageProviders.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get the token price to the currency
    ///
    /// - Remark: HTTP `GET /v2/rates`.
    /// - Remark: Generated from `#/paths//v2/rates/get(getRates)`.
    public func getRates(_ input: Operations.getRates.Input) async throws -> Operations.getRates.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getRates.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/rates", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "tokens",
                    value: input.query.tokens
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "currencies",
                    value: input.query.currencies
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRates.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRates.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get chart by token
    ///
    /// - Remark: HTTP `GET /v2/rates/chart`.
    /// - Remark: Generated from `#/paths//v2/rates/chart/get(getChartRates)`.
    public func getChartRates(_ input: Operations.getChartRates.Input) async throws -> Operations.getChartRates.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getChartRates.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/rates/chart", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "token",
                    value: input.query.token
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "currency",
                    value: input.query.currency
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "start_date",
                    value: input.query.start_date
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "end_date",
                    value: input.query.end_date
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getChartRates.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getChartRates.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get a payload for further token receipt
    ///
    /// - Remark: HTTP `GET /v2/tonconnect/payload`.
    /// - Remark: Generated from `#/paths//v2/tonconnect/payload/get(getTonConnectPayload)`.
    public func getTonConnectPayload(_ input: Operations.getTonConnectPayload.Input) async throws
        -> Operations.getTonConnectPayload.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getTonConnectPayload.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/tonconnect/payload", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getTonConnectPayload.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getTonConnectPayload.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get account info by state init
    ///
    /// - Remark: HTTP `POST /v2/tonconnect/stateinit`.
    /// - Remark: Generated from `#/paths//v2/tonconnect/stateinit/post(getAccountInfoByStateInit)`.
    public func getAccountInfoByStateInit(_ input: Operations.getAccountInfoByStateInit.Input) async throws
        -> Operations.getAccountInfoByStateInit.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountInfoByStateInit.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/tonconnect/stateinit", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountInfoByStateInit.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.AccountInfoByStateInit.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get backup info
    ///
    /// - Remark: HTTP `GET /v2/wallet/backup`.
    /// - Remark: Generated from `#/paths//v2/wallet/backup/get(getWalletBackup)`.
    public func getWalletBackup(_ input: Operations.getWalletBackup.Input) async throws
        -> Operations.getWalletBackup.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getWalletBackup.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/wallet/backup", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWalletBackup.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getWalletBackup.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Set backup info
    ///
    /// - Remark: HTTP `PUT /v2/wallet/backup`.
    /// - Remark: Generated from `#/paths//v2/wallet/backup/put(setWalletBackup)`.
    public func setWalletBackup(_ input: Operations.setWalletBackup.Input) async throws
        -> Operations.setWalletBackup.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.setWalletBackup.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/wallet/backup", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .put)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsURI(
                    in: &request.headerFields,
                    name: "X-TonConnect-Auth",
                    value: input.headers.X_hyphen_TonConnect_hyphen_Auth
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .binary(value):
                    body = try converter.setRequiredRequestBodyAsBinary(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/octet-stream"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200: return .ok(.init())
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Account verification and token issuance
    ///
    /// - Remark: HTTP `POST /v2/wallet/auth/proof`.
    /// - Remark: Generated from `#/paths//v2/wallet/auth/proof/post(tonConnectProof)`.
    public func tonConnectProof(_ input: Operations.tonConnectProof.Input) async throws
        -> Operations.tonConnectProof.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.tonConnectProof.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/wallet/auth/proof", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.tonConnectProof.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.tonConnectProof.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get wallets by public key
    ///
    /// - Remark: HTTP `GET /v2/pubkeys/{public_key}/wallets`.
    /// - Remark: Generated from `#/paths//v2/pubkeys/{public_key}/wallets/get(getWalletsByPublicKey)`.
    public func getWalletsByPublicKey(_ input: Operations.getWalletsByPublicKey.Input) async throws
        -> Operations.getWalletsByPublicKey.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getWalletsByPublicKey.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/pubkeys/{}/wallets",
                    parameters: [input.path.public_key]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getWalletsByPublicKey.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Accounts.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get account seqno
    ///
    /// - Remark: HTTP `GET /v2/wallet/{account_id}/seqno`.
    /// - Remark: Generated from `#/paths//v2/wallet/{account_id}/seqno/get(getAccountSeqno)`.
    public func getAccountSeqno(_ input: Operations.getAccountSeqno.Input) async throws
        -> Operations.getAccountSeqno.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAccountSeqno.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/wallet/{}/seqno",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAccountSeqno.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Schemas.Seqno.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw masterchain info
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_masterchain_info`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_masterchain_info/get(getRawMasterchainInfo)`.
    public func getRawMasterchainInfo(_ input: Operations.getRawMasterchainInfo.Input) async throws
        -> Operations.getRawMasterchainInfo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawMasterchainInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/liteserver/get_masterchain_info", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawMasterchainInfo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawMasterchainInfo.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw masterchain info ext
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_masterchain_info_ext`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_masterchain_info_ext/get(getRawMasterchainInfoExt)`.
    public func getRawMasterchainInfoExt(_ input: Operations.getRawMasterchainInfoExt.Input) async throws
        -> Operations.getRawMasterchainInfoExt.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawMasterchainInfoExt.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_masterchain_info_ext",
                    parameters: []
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mode",
                    value: input.query.mode
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawMasterchainInfoExt.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawMasterchainInfoExt.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw time
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_time`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_time/get(getRawTime)`.
    public func getRawTime(_ input: Operations.getRawTime.Input) async throws -> Operations.getRawTime.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getRawTime.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/liteserver/get_time", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawTime.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawTime.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw blockchain block
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_block/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_block/{block_id}/get(getRawBlockchainBlock)`.
    public func getRawBlockchainBlock(_ input: Operations.getRawBlockchainBlock.Input) async throws
        -> Operations.getRawBlockchainBlock.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawBlockchainBlock.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_block/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawBlockchainBlock.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawBlockchainBlock.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw blockchain block state
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_state/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_state/{block_id}/get(getRawBlockchainBlockState)`.
    public func getRawBlockchainBlockState(_ input: Operations.getRawBlockchainBlockState.Input) async throws
        -> Operations.getRawBlockchainBlockState.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawBlockchainBlockState.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_state/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawBlockchainBlockState.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawBlockchainBlockState.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw blockchain block header
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_block_header/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_block_header/{block_id}/get(getRawBlockchainBlockHeader)`.
    public func getRawBlockchainBlockHeader(_ input: Operations.getRawBlockchainBlockHeader.Input) async throws
        -> Operations.getRawBlockchainBlockHeader.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawBlockchainBlockHeader.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_block_header/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mode",
                    value: input.query.mode
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawBlockchainBlockHeader.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawBlockchainBlockHeader.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Send raw message to blockchain
    ///
    /// - Remark: HTTP `POST /v2/liteserver/send_message`.
    /// - Remark: Generated from `#/paths//v2/liteserver/send_message/post(sendRawMessage)`.
    public func sendRawMessage(_ input: Operations.sendRawMessage.Input) async throws
        -> Operations.sendRawMessage.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.sendRawMessage.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/liteserver/send_message", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                let body: OpenAPIRuntime.HTTPBody?
                switch input.body {
                case let .json(value):
                    body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return (request, body)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.sendRawMessage.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.sendRawMessage.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw account state
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_account_state/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_account_state/{account_id}/get(getRawAccountState)`.
    public func getRawAccountState(_ input: Operations.getRawAccountState.Input) async throws
        -> Operations.getRawAccountState.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawAccountState.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_account_state/{}",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "target_block",
                    value: input.query.target_block
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawAccountState.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawAccountState.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw shard info
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_shard_info/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_shard_info/{block_id}/get(getRawShardInfo)`.
    public func getRawShardInfo(_ input: Operations.getRawShardInfo.Input) async throws
        -> Operations.getRawShardInfo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawShardInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_shard_info/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "workchain",
                    value: input.query.workchain
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "shard",
                    value: input.query.shard
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "exact",
                    value: input.query.exact
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawShardInfo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawShardInfo.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get all raw shards info
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_all_shards_info/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_all_shards_info/{block_id}/get(getAllRawShardsInfo)`.
    public func getAllRawShardsInfo(_ input: Operations.getAllRawShardsInfo.Input) async throws
        -> Operations.getAllRawShardsInfo.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getAllRawShardsInfo.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_all_shards_info/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getAllRawShardsInfo.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getAllRawShardsInfo.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw transactions
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_transactions/{account_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_transactions/{account_id}/get(getRawTransactions)`.
    public func getRawTransactions(_ input: Operations.getRawTransactions.Input) async throws
        -> Operations.getRawTransactions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_transactions/{}",
                    parameters: [input.path.account_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "count",
                    value: input.query.count
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "lt",
                    value: input.query.lt
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hash",
                    value: input.query.hash
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawTransactions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawTransactions.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw list block transactions
    ///
    /// - Remark: HTTP `GET /v2/liteserver/list_block_transactions/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/list_block_transactions/{block_id}/get(getRawListBlockTransactions)`.
    public func getRawListBlockTransactions(_ input: Operations.getRawListBlockTransactions.Input) async throws
        -> Operations.getRawListBlockTransactions.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawListBlockTransactions.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/list_block_transactions/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mode",
                    value: input.query.mode
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "count",
                    value: input.query.count
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_id",
                    value: input.query.account_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "lt",
                    value: input.query.lt
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawListBlockTransactions.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawListBlockTransactions.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw block proof
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_block_proof`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_block_proof/get(getRawBlockProof)`.
    public func getRawBlockProof(_ input: Operations.getRawBlockProof.Input) async throws
        -> Operations.getRawBlockProof.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawBlockProof.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/v2/liteserver/get_block_proof", parameters: [])
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "known_block",
                    value: input.query.known_block
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "target_block",
                    value: input.query.target_block
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mode",
                    value: input.query.mode
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawBlockProof.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawBlockProof.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw config
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_config_all/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_config_all/{block_id}/get(getRawConfig)`.
    public func getRawConfig(_ input: Operations.getRawConfig.Input) async throws -> Operations.getRawConfig.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getRawConfig.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_config_all/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "mode",
                    value: input.query.mode
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawConfig.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawConfig.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
    /// Get raw shard block proof
    ///
    /// - Remark: HTTP `GET /v2/liteserver/get_shard_block_proof/{block_id}`.
    /// - Remark: Generated from `#/paths//v2/liteserver/get_shard_block_proof/{block_id}/get(getRawShardBlockProof)`.
    public func getRawShardBlockProof(_ input: Operations.getRawShardBlockProof.Input) async throws
        -> Operations.getRawShardBlockProof.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getRawShardBlockProof.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/v2/liteserver/get_shard_block_proof/{}",
                    parameters: [input.path.block_id]
                )
                var request: HTTPTypes.HTTPRequest = .init(soar_path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return (request, nil)
            },
            deserializer: { response, responseBody in
                switch response.status.code {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getRawShardBlockProof.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Operations.getRawShardBlockProof.Output.Ok.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Components.Responses._Error.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try await converter.getResponseBodyAsJSON(
                            Components.Responses._Error.Body.jsonPayload.self,
                            from: responseBody,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .`default`(statusCode: response.status.code, .init(body: body))
                }
            }
        )
    }
}
