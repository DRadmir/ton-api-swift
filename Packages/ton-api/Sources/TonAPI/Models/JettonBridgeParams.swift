//
// JettonBridgeParams.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct JettonBridgeParams: Codable, JSONEncodable, Hashable {

    public var bridgeAddress: String
    public var oraclesAddress: String
    public var stateFlags: Int
    public var burnBridgeFee: Int64?
    public var oracles: [Oracle]
    public var externalChainAddress: String?
    public var prices: JettonBridgePrices?

    public init(bridgeAddress: String, oraclesAddress: String, stateFlags: Int, burnBridgeFee: Int64? = nil, oracles: [Oracle], externalChainAddress: String? = nil, prices: JettonBridgePrices? = nil) {
        self.bridgeAddress = bridgeAddress
        self.oraclesAddress = oraclesAddress
        self.stateFlags = stateFlags
        self.burnBridgeFee = burnBridgeFee
        self.oracles = oracles
        self.externalChainAddress = externalChainAddress
        self.prices = prices
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case bridgeAddress = "bridge_address"
        case oraclesAddress = "oracles_address"
        case stateFlags = "state_flags"
        case burnBridgeFee = "burn_bridge_fee"
        case oracles
        case externalChainAddress = "external_chain_address"
        case prices
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(bridgeAddress, forKey: .bridgeAddress)
        try container.encode(oraclesAddress, forKey: .oraclesAddress)
        try container.encode(stateFlags, forKey: .stateFlags)
        try container.encodeIfPresent(burnBridgeFee, forKey: .burnBridgeFee)
        try container.encode(oracles, forKey: .oracles)
        try container.encodeIfPresent(externalChainAddress, forKey: .externalChainAddress)
        try container.encodeIfPresent(prices, forKey: .prices)
    }
}

